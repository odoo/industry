<?xml version='1.0' encoding='UTF-8'?>
<odoo>
    <record id="compute_run_time_increment" model="ir.actions.server">
        <field name="code"><![CDATA[
rtms = env['x_run_time_meter'].search([('id', 'in', records.x_serial_id.x_run_time_meter_ids.ids)], order='x_serial_id, x_date')
for i in range(len(rtms)):
    rtms[i]['x_run_time_increment_h'] = rtms[i].x_run_time - (rtms[i - 1].x_run_time if i > 0 and rtms[i - 1].x_serial_id == rtms[i].x_serial_id else 0)
    ]]></field>
        <field name="model_id" ref="x_run_time_meter_model"/>
        <field name="state">code</field>
        <field name="name">Compute Run-Time Increment</field>
        <field name="usage">base_automation</field>
    </record>
    <record id="run_time_meter_when_done" model="ir.actions.server">
        <field name="code"><![CDATA[
for task in records: task['x_run_time_meter_when_done'] = task.x_serial_id.x_run_time_meter_h
    ]]></field>
        <field name="model_id" ref="project.model_project_task"/>
        <field name="state">code</field>
        <field name="name">Run-Time Meter When Done</field>
        <field name="usage">base_automation</field>
    </record>
    <record id="create_recurrent_tasks_server_action" model="ir.actions.server">
        <field name="name">Create Recurrent Tasks Based On Recurring Maintenance Rules</field>
        <field name="model_id" ref="stock.model_stock_lot"/>
        <field name="state">code</field>
        <field name="usage">ir_cron</field>
        <field name="code"><![CDATA[
for maintenance_rule in env['x_recurring_maintenance_rules'].search([('x_active', '=', True)]):
    for serial in maintenance_rule.x_product_id.x_serial_ids:
        tasks = env['project.task'].search([('is_fsm', '=', True), ('x_serial_id', '=', serial.id), ('x_recurring_maintenance_rule_id', '=', maintenance_rule.id)])
        last_maintenance = max(tasks.filtered(lambda t: t.state == '1_done').mapped('x_run_time_meter_when_done'), default=0.0)
        on_maintenance = len(tasks.filtered(lambda t: t.state not in ['1_done', '1_canceled'])) > 0
        if not on_maintenance and serial.x_run_time_meter_h - last_maintenance >= maintenance_rule.x_run_time_increment_h:
            project_task = env['project.task'].create({
                'name': '[Recurrent] ' + serial.name,
                'x_serial_id': serial.id,
                'partner_id': env.ref('base.main_company').id,
                'under_warranty': True,
                'x_maintenance': 'recurrent',
                'x_recurring_maintenance_rule_id': maintenance_rule.id,
                'is_fsm': True,
                'project_id': env.ref('industry_fsm.fsm_project').id,
            })
    ]]></field>
    </record>
    <record id="create_recurrent_tasks_cron" model="ir.cron">
        <field name="interval_type">days</field>
        <field name="interval_number">1</field>
        <field name="state">code</field>
        <field name="ir_actions_server_id" ref="create_recurrent_tasks_server_action"/>
    </record>
    <!-- May be used differently depending on the module, so the code to call this server action is in the module using usage_based_maintenance -->
    <record id="create_corrective_task" model="ir.actions.server">
        <field name="model_id" ref="stock.model_stock_move"/>
        <field name="state">code</field>
        <field name="name">Create Corrective Task</field>
        <field name="usage">base_automation</field>
        <field name="code"><![CDATA[
for record in records:
    if not record.picking_id.quality_check_fail: continue
    for lot in record.move_line_ids.lot_id:
        project_task = env['project.task'].create({
            'name': '[Corrective] ' + lot.name,
            'x_serial_id': lot.id,
            'partner_id': record.picking_id.partner_id.id,
            'under_warranty': True,
            'is_fsm': True,
            'project_id': env.ref('industry_fsm.fsm_project').id,
            'x_maintenance': 'corrective',
        })
        ]]></field>
    </record>
</odoo>
